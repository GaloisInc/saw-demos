// Import the Cryptol specification for dot product
import "dotprod.cry";

// Include common LLVM utilities
include "../../common/llvm.saw";

// This function provides a new vec_t of a given size
let vec_t (name : String) (rw : Term) (size : Int) = do {
  elts <- alloc (str_concat name ".elts") rw (llvm_array size uint32_t);
  let sizet = from_cryptol {{ `size : [32] }};

  vec_struct <- struct [ elts.p, sizet ] "vec_t" rw;
  return {p=vec_struct.p, s=vec_struct.s, size={s=size, t=sizet}, elts=elts};
};

// This function specifies what the `dotprod` function should do when
// given an input of size `n`.

//uint32_t dotprod(vec_t *x, vec_t *y)
let dotprod_spec n = do {
    x <- vec_t "x" CONST n;
    y <- vec_t "y" CONST n;

    execute [x.p, y.p];

    let (xst, yst) = ((x.elts).t, (y.elts).t);
    returns (from_cryptol {{ dotprod xst yst }});
};

// The same spec as above, but for the case where both input pointers
// point to the same object.
//uint32_t dotprod(vec_t *x, vec_t *x)
let dotprod_aliased_spec n = do {
    x <- vec_t "x" CONST n;

    execute [x.p, x.p];
    let xst = (x.elts).t;
    returns (from_cryptol {{ dotprod xst xst }});
};

// Load the LLVM bitcode file generated from `dotprod.c`
m <- llvm_load_module "dotprod.bc";

let size = 4;

// Verify the distinct version
dotprod_ov <- llvm_verify m "dotprod" [] (dotprod_spec size);

// Test simply to demonstrate how overrides are applied
llvm_verify m "dotprod" [dotprod_ov] (dotprod_spec size);

// Verify the aliased version
dotprod_aliased_ov <- llvm_verify m "dotprod" [] (dotprod_aliased_spec size);

// Test simply to demonstrate how overrides are applied
llvm_verify m "dotprod" [dotprod_aliased_ov] (dotprod_aliased_spec size);

