// Import the Cryptol specification for dot product
import "dotprod.cry";

// Include common LLVM utilities
include "../../common/llvm.saw";

// This function specifies what the `dotprod` function should do when
// given an input of size `n`.
let dotprod_spec n = do {
    let nt = from_cryptol {{ `n : [32] }};
    xs <- alloc "xs" (llvm_array n uint32_t);
    ys <- alloc "ys" (llvm_array n uint32_t);
    let xval = struct [ xs.p, nt ];
    let yval = struct [ ys.p, nt ];
    xp <- alloc_init (struct_t "vec_t") xval;
    yp <- alloc_init (struct_t "vec_t") yval;
    execute [xp, yp];
    let (xst, yst) = (xs.t, ys.t);
    returns (from_cryptol {{ dotprod xst yst }});
};

// The same spec as above, but for the case where both input pointers
// point to the same object.
let dotprod_aliased_spec n = do {
    let nt = from_cryptol {{ `n : [32] }};
    xs <- alloc "xs" (llvm_array n uint32_t);
    let xval = struct [ xs.p, nt ];
    xp <- alloc_init (struct_t "vec_t") xval;
    execute [xp, xp];
    let xst = xs.t;
    returns (from_cryptol {{ dotprod xst xst }});
};

// Load the LLVM bitcode file generated from `dotprod.c`
m <- llvm_load_module "dotprod.bc";

let sz = 4;

// Verify the distinct version
dotprod_ov <- crucible_llvm_verify m "dotprod" [] true (dotprod_spec sz) z3;
crucible_llvm_verify m "dotprod_wrap" [dotprod_ov] true (dotprod_spec sz) z3;

// Verify the aliased version
dotprod_aliased_ov <- crucible_llvm_verify m "dotprod" [] true (dotprod_aliased_spec sz) z3;
crucible_llvm_verify m "dotprod_wrap" [dotprod_aliased_ov] true (dotprod_aliased_spec sz) z3;
