// Import the Cryptol specification for dot product
import "dotprod.cry";

// Include common LLVM utilities
include "../../common/llvm.saw";

// This function provides a new vec_t of a given size
let vec_t (name : String) (rw : Term) (n : Int) = do {
  //Create the structure
  elts <- alloc (str_concat name ".elts") rw (llvm_array n uint32_t);
  size <- variable "size" uint32_t (CON {{ `n : [32] }});
  vec <- struct "vec_t" rw [ elts.p, size.s ];

  //Create the Term for the structure (for use in Cryptol expressions)
  let (sizet, eltst) = (size.t, elts.t);
  let vect = {{ {size=sizet, elts=eltst} }};

  //Return a pointer, a SetupValue, and a Term for the new vec_t.
  return {p=vec.p, s=vec.s, t=vect};
};

// This function specifies what the `dotprod` function should do when
// given an input of size `n`.

//uint32_t dotprod(vec_t *x, vec_t *y)
let dotprod_spec n = do {
    x <- vec_t "x" CONST n;
    y <- vec_t "y" CONST n;

    execute [x.p, y.p];

    let (xt, yt) = (x.t, y.t);
    returns (from_cryptol {{ dotprod xt.elts yt.elts }});
};

// The same spec as above, but for the case where both input pointers
// point to the same object.
//uint32_t dotprod(vec_t *x, vec_t *x)
let dotprod_aliased_spec n = do {
    x <- vec_t "x" CONST n;

    execute [x.p, x.p];

    let xt = x.t;
    returns (from_cryptol {{ dotprod xt.elts xt.elts }});
};

// Load the LLVM bitcode file generated from `dotprod.c`
m <- llvm_load_module "dotprod.bc";

let size = 4;

// Verify the distinct version
dotprod_ov <- llvm_verify m "dotprod" [] (dotprod_spec size);

// Test simply to demonstrate how overrides are applied
llvm_verify m "dotprod" [dotprod_ov] (dotprod_spec size);

// Verify the aliased version
dotprod_aliased_ov <- llvm_verify m "dotprod" [] (dotprod_aliased_spec size);

// Test simply to demonstrate how overrides are applied
llvm_verify m "dotprod" [dotprod_aliased_ov] (dotprod_aliased_spec size);

