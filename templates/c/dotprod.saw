// Import the Cryptol specification for dot product
import "dotprod.cry";

// Include common LLVM utilities
include "../../common/llvm.saw";

// This function provides a new vec_t of a given size
let vec_t (name : String) (rw : Term) (size : Int) = do {
  elts <- alloc (str_concat name ".elts") rw (llvm_array size uint32_t);
  let eltst = elts.t;
  
  let sizet = {{ `size : [32] }};
  let sizes = from_cryptol sizet;

  let vect = {{ {size=sizet, elts=eltst} }};

  vec <- struct [ elts.p, sizes ] "vec_t" rw;
  return {p=vec.p, s=vec.s, t=vect};
};

// This function specifies what the `dotprod` function should do when
// given an input of size `n`.

//uint32_t dotprod(vec_t *x, vec_t *y)
let dotprod_spec n = do {
    x <- vec_t "x" CONST n;
    y <- vec_t "y" CONST n;

    execute [x.p, y.p];

    let (xt, yt) = (x.t, y.t);
    returns (from_cryptol {{ dotprod xt.elts yt.elts }});
};

// The same spec as above, but for the case where both input pointers
// point to the same object.
//uint32_t dotprod(vec_t *x, vec_t *x)
let dotprod_aliased_spec n = do {
    x <- vec_t "x" CONST n;

    execute [x.p, x.p];

    let xt = x.t;
    returns (from_cryptol {{ dotprod xt.elts xt.elts }});
};

// Load the LLVM bitcode file generated from `dotprod.c`
m <- llvm_load_module "dotprod.bc";

let size = 4;

// Verify the distinct version
dotprod_ov <- llvm_verify m "dotprod" [] (dotprod_spec size);

// Test simply to demonstrate how overrides are applied
llvm_verify m "dotprod" [dotprod_ov] (dotprod_spec size);

// Verify the aliased version
dotprod_aliased_ov <- llvm_verify m "dotprod" [] (dotprod_aliased_spec size);

// Test simply to demonstrate how overrides are applied
llvm_verify m "dotprod" [dotprod_aliased_ov] (dotprod_aliased_spec size);

